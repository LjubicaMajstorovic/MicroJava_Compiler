package rs.ac.bg.etf.pp1.parser.generated;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.parser.generated.ast.*;

parser code {:
	private Logger log = Logger.getLogger(getClass());
	public boolean errorDetected = false;
	
    public void report_error(String message, Object info) {
    	errorDetected = true;
		int line = 0;
		
		if (info instanceof Symbol) line = ((Symbol)info).left; 
		else if (info instanceof Integer) line = (int)info;
		
		if (line == 0) log.error(message);
		else log.error(message + " (linija " + line + ")");
    }
    
    public void syntax_error(Symbol cur_token) {
        report_error("Sintaksna greska", cur_token);
    }
     
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje ne moze da se nastavi", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) {
		log.info(s + " " + s.value.toString());
	} else if (s != null) {
		log.info(s);
	}
	return s;
:}

terminal PROGRAM, BREAK, CONST, ELSE, IF, NEW, PRINT, READ, RETURN, VOID, CONTINUE, FOR, DO, WHILE, MAP, ASSIGN, UNION;
terminal PLUS, MINUS, ASTERISK, DIVIDE, MODULO, DBL_EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL, AND, OR, INC, DEC, SEMI, COLON, COMMA, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal Integer NUM, BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program, DeclarationListConNVar, DeclarationListMethods, DeclarationListCon, DeclarationListVar, ConstVal, DeclareConst, DeclareListCon, Type, DeclareVar, DeclareListVar;
nonterminal ReturnType, ArgumentsAndVarDecl, ListStatements, MethodDeclaration, ArgumentsList, Argument, ArgumentAdd, Statement;
nonterminal DesignatorStatment, Condition, ElseStatement, Expr, PrintExpr, DoWhileCondition, Designator, AssignOp, RealArgs, SetOp;
nonterminal Term, Factor, MulOp, AddOp, RelOp, RealArgsList, RealArg, ConditionTerm, ConditionFact;

Program ::= (Program) PROGRAM IDENT DeclarationListConNVar LBRACE DeclarationListMethods RBRACE;
DeclarationListConNVar ::= (DeclarationListConNVarC) DeclarationListConNVar DeclarationListCon
                           |
                           (DeclarationListConNVarV) DeclarationListConNVar DeclarationListVar
                           |
                           (EpsilonDC) /* epsilon */;

DeclarationListCon ::= (DeclarationListCon) CONST Type DeclareConst DeclareListCon SEMI;
DeclareConst ::= (DeclareConst) IDENT ASSIGN ConstVal;
DeclareListCon ::= (DeclareListConAdd) COMMA DeclareConst DeclareListCon
                   |
                   (EpsilonDLC) /* epsilon */ ;
ConstVal ::= (Number1) NUM
             |
             (Boolean1) BOOL
             |
             (Character1) CHAR;

DeclarationListVar ::= (DeclarationListVar) Type DeclareVar DeclareListVar SEMI;
DeclareVar ::= (Var) IDENT
               |
               (Arr) IDENT LBRACKET RBRACKET;
DeclareListVar ::= (DeclareListVarAdd) COMMA DeclareVar DeclareListVar
                   |
                   (EpsilonDLV) /* epsilon */ ;
Type ::= (Type) IDENT;

DeclarationListMethods ::= (DeclarationListMethodsAdd) DeclarationListMethods MethodDeclaration
                           |
                           (EpsilonDLM) /* epsilon */;
MethodDeclaration ::= (MethodDeclaration) ReturnType IDENT ArgumentsAndVarDecl LBRACE ListStatements RBRACE;
ReturnType ::= (NonVoid) Type
               |
               (Void1) VOID;
ArgumentsAndVarDecl ::= (ArgumentsAndVarDecl) LPAREN ArgumentsList RPAREN DeclarationListVar;
ArgumentsList ::= (ArgumentsListAdd) Argument ArgumentAdd
                  |
                  (EpsilonAL) /* epsilon */;
ArgumentAdd ::= (ArgumentAdd1) COMMA Argument ArgumentAdd
                |
                (EpsilonAA) /* epsilon */;
Argument ::= (ArgumentVar) Type IDENT
             |
             (ArgumentArr) Type IDENT LBRACKET RBRACKET;

ListStatements ::= (ListStatementsAdd) ListStatements Statement
                   |
                   (EpsilonLSA) /* epsilon */;
Statement ::= (StatmentDESIG) DesignatorStatment SEMI
              |
              (StatementIF) IF LPAREN Condition RPAREN Statement ElseStatement
              |
              (StatementB) BREAK SEMI
              |
              (StatementC) CONTINUE SEMI
              |
              (StatementRV) RETURN SEMI
              |
              (StatementRNV) RETURN Expr SEMI
              |
              (StetementR) READ LPAREN Designator RPAREN SEMI
              |
              (StatementP) PRINT LPAREN PrintExpr RPAREN SEMI
              |
              (StatementDO) DO Statement WHILE LPAREN DoWhileCondition RPAREN SEMI
              |
              (Statements) LBRACE ListStatements RBRACE;

DesignatorStatment ::= (Assign) Designator AssignOp Expr
                       |
                       (MethodCall) Designator LPAREN RealArgs RPAREN
                       |
                       (Inc) Designator INC
                       |
                       (Dec) Designator DEC
                       |
                       (SetOperation) Designator AssignOp Designator SetOp Designator;
Designator ::= (Variable) IDENT
               |
               (ArrayElem) IDENT LBRACKET Expr RBRACKET;
AssignOp ::= (AssignOp) ASSIGN;

Expr ::= (ExprList) Expr AddOp Term
         |
         (ExprT) Term
         |
         (MinusExprT) MINUS Term;

Term ::= (TermMulOp) Term MulOp Factor
         |
         (TermF) Factor;

Factor ::= (FactorDes) Designator
        |
        (FactorMethod) Designator LPAREN RealArgs RPAREN
        |
        (FactorNumber) NUM
        |
        (FactorCharacter) CHAR
        |
        (FactorBool) BOOL
        |
        (FactorNewArr) NEW Type LBRACKET Expr RBRACKET
        |
        (FactorExpr) LPAREN Expr RPAREN
        ;

AddOp ::= (AddOpPlus) PLUS
          |
          (AddOpMinus) MINUS;

MulOp ::= (MulOpMul) ASTERISK
          |
          (MulOpDiv) DIVIDE
          |
          (MulOpMod) MODULO;

SetOp ::= (SetOpUnion) UNION;

RelOp ::= (RelOpEquals) DBL_EQUAL
          | (RelOpNotEquals) NOT_EQUAL
          | (RelOpGreatern) GREATER
          | (RelOpGreaterEqual) GREATER_EQUAL
          | (RelOpLessThan) LESS
          | (RelOpLessEqual) LESS_EQUAL;

RealArgs ::= (RealArgsList) RealArg RealArgsList
             |
             (EpsilonRealArgs) /* epsilon */;

RealArgsList::= (RealArgsListAdd) COMMA RealArg RealArgsList
                |
                (EpsilonRealArgsList) /* epsilon */;
RealArg ::= Expr;

Condition ::= (OneCondition) ConditionTerm
              |
              (MoreCondition) Condition OR ConditionTerm;

ConditionTerm ::= (OneConditionFact) ConditionFact
                  |
                  (MoreConditionFacts) ConditionTerm AND ConditionFact;

ConditionFact ::= (ConditionFactExpr) Expr
                  |
                  (ConditionFactRelOp) Expr RelOp Expr;



