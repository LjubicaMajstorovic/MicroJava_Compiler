package rs.ac.bg.etf.pp1.parser.generated;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.parser.generated.ast.*;

parser code {:
	private Logger log = Logger.getLogger(getClass());
	public boolean errorDetected = false;
	
    public void report_error(String message, Object info) {
    	errorDetected = true;
		int line = 0;
		
		if (info instanceof Symbol) line = ((Symbol)info).left; 
		else if (info instanceof Integer) line = (int)info;
		
		if (line == 0) log.error(message);
		else log.error(message + " (linija " + line + ")");
    }
    
    public void syntax_error(Symbol cur_token) {
        report_error("Sintaksna greska", cur_token);
    }
     
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje ne moze da se nastavi", cur_token);
    }
    
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) {
		log.info(s + " " + s.value.toString());
	} else if (s != null) {
		log.info(s);
	}
	return s;
:}

terminal PROGRAM, BREAK, CONST, ELSE, IF, NEW, PRINT, READ, RETURN, VOID, CONTINUE, FOR, DO, WHILE, MAP, ASSIGN, UNION;
terminal PLUS, MINUS, ASTERISK, DIVIDE, MODULO, DBL_EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL, AND, OR, INC, DEC, SEMI, COLON, COMMA, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal MAIN;
terminal ORD, CHR, ADD, ADDALL;
terminal Integer NUM, BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program, DeclarationListConNVar, DeclarationListMethods, DeclarationListCon, DeclarationListVar, ConstVal, DeclareConst, DeclareListCon, Type, DeclareVar, DeclareListVar;
nonterminal ReturnType, ArgumentsAndVarDecl, ListStatements, MethodDeclaration, ArgumentsList, Argument, ArgumentAdd, Statement;
nonterminal DesignatorStatment, Condition, ElseStatement, PrintExpr, DoWhileCondition, AssignOp, RealArgs, SetOp;
nonterminal MulOp, AddOp, RelOp, RealArgsList, RealArg, ConditionTerm, ConditionFact, MultipleDeclarationListVar, ProgramName, MainDeclare;
nonterminal VoidMethodsCall;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr, NonVoidMethodsCall;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, ArrayVarName;

precedence left ELSE;

Program ::= (Program) PROGRAM ProgramName DeclarationListConNVar LBRACE MethodDeclaration RBRACE;
ProgramName ::= (ProgramName) IDENT;
DeclarationListConNVar ::= (DeclarationListConNVarC) DeclarationListConNVar DeclarationListCon
                           |
                           (DeclarationListConNVarV) DeclarationListConNVar DeclarationListVar
                           |
                           (EpsilonDC) /* epsilon */;

DeclarationListCon ::= (DeclarationListCon) CONST Type DeclareConst DeclareListCon SEMI;
DeclareConst ::= (DeclareConst) IDENT ASSIGN ConstVal;
DeclareListCon ::= (DeclareListConAdd) COMMA DeclareConst DeclareListCon
                   |
                   (EpsilonDLC) /* epsilon */ ;
ConstVal ::= (Number1) NUM
             |
             (Boolean1) BOOL
             |
             (Character1) CHAR;

DeclarationListVar ::= (DeclarationListVar) Type DeclareVar DeclareListVar SEMI;
DeclareVar ::= (Var) IDENT
               |
               (Arr) IDENT LBRACKET RBRACKET;
DeclareListVar ::= (DeclareListVarAdd) COMMA DeclareVar DeclareListVar
                   |
                   (EpsilonDLV) /* epsilon */ ;
Type ::= (Type) IDENT;

DeclarationListMethods ::= (DeclarationListMethodsAdd) DeclarationListMethods MethodDeclaration
                           |
                           (EpsilonDLM) /* epsilon */;

MethodDeclaration ::= (MethodDeclaration) MainDeclare MultipleDeclarationListVar LBRACE ListStatements RBRACE;
MainDeclare ::= (MainDeclare) VOID MAIN LPAREN RPAREN;
ReturnType ::= (NonVoid) Type
               |
               (Void1) VOID;
ArgumentsAndVarDecl ::= (ArgumentsAndVarDecl) LPAREN ArgumentsList RPAREN MultipleDeclarationListVar;

MultipleDeclarationListVar ::= (MulitipleDeclareVars) MultipleDeclarationListVar DeclarationListVar
                               |
                               (EpsilonMultipleDLV) /* epsilon */;

ArgumentsList ::= (ArgumentsListAdd) Argument ArgumentAdd
                  |
                  (EpsilonAL) /* epsilon */;
ArgumentAdd ::= (ArgumentAdd1) COMMA Argument ArgumentAdd
                |
                (EpsilonAA) /* epsilon */;
Argument ::= (ArgumentVar) Type IDENT
             |
             (ArgumentArr) Type IDENT LBRACKET RBRACKET;

ListStatements ::= (ListStatementsAdd) ListStatements Statement
                   |
                   (EpsilonLSA) /* epsilon */;
Statement ::= (StatmentDESIG) DesignatorStatment SEMI
              |
              (StatementIf) IF LPAREN Condition RPAREN Statement ElseStatement
              |
              (StatementB) BREAK SEMI
              |
              (StatementC) CONTINUE SEMI
              |
              (StatementRV) RETURN SEMI
              |
              (StetementR) READ LPAREN Designator RPAREN SEMI
              |
              (StatementPrint) PRINT LPAREN Expr RPAREN SEMI
              |
              (SingleStatementPrintExprAndNumber) PRINT LPAREN Expr COMMA NUM RPAREN SEMI
              |
              (StatementDO) DO Statement WHILE LPAREN DoWhileCondition RPAREN SEMI
              |
              (Statements) LBRACE ListStatements RBRACE;

DesignatorStatment ::= (Assign) Designator AssignOp Expr
                       |
                       (MethodCall) Designator LPAREN RealArgs RPAREN
                       |
                       (VoidMethods) VoidMethodsCall
                       |
                       (NonVoidMethods) NonVoidMethodsCall
                       |
                       (Inc) Designator INC
                       |
                       (Dec) Designator DEC
                       |
                       (SetOperation) Designator AssignOp Designator SetOp Designator;

VoidMethodsCall ::= (AddCall) ADD LPAREN Expr COMMA Expr RPAREN
                    |
                    (AddAllCall) ADDALL LPAREN Expr COMMA Expr RPAREN;

NonVoidMethodsCall ::= (ChrCall) CHR LPAREN Expr RPAREN
                       |
                       (OrdCall) ORD LPAREN Expr RPAREN;

Designator ::= (Variable) IDENT
               |
               (ArrayElem) ArrayVarName LBRACKET Expr RBRACKET;

ArrayVarName ::= (ArrayVarName) IDENT;

AssignOp ::= (AssignOp) ASSIGN;

Expr ::= (ExprList) Expr AddOp Term
         |
         (ExprT) Term
         |
         (MinusExprT) MINUS Term;

Term ::= (TermMulOp) Term MulOp Factor
         |
         (TermF) Factor;

Factor ::= (FactorDes) Designator
        |
        (FactorMethod) Designator LPAREN RealArgs RPAREN
        |
        (FactorNumber) NUM
        |
        (FactorCharacter) CHAR
        |
        (FactorBool) BOOL
        |
        (FactorNewArrOrSet) NEW Type LBRACKET Expr RBRACKET
        |
        (FactorExpr) LPAREN Expr RPAREN
        |
        (FactorMethodCall) NonVoidMethodsCall;

AddOp ::= (AddOpPlus) PLUS
          |
          (AddOpMinus) MINUS;

MulOp ::= (MulOpMul) ASTERISK
          |
          (MulOpDiv) DIVIDE
          |
          (MulOpMod) MODULO;

SetOp ::= (SetOpUnion) UNION;

RelOp ::= (RelOpEquals) DBL_EQUAL
          | (RelOpNotEquals) NOT_EQUAL
          | (RelOpGreatern) GREATER
          | (RelOpGreaterEqual) GREATER_EQUAL
          | (RelOpLessThan) LESS
          | (RelOpLessEqual) LESS_EQUAL;

RealArgs ::= (RealArgsLists) RealArg RealArgsList
             |
             (EpsilonRealArgs) /* epsilon */;

RealArgsList::= (RealArgsListAdd) COMMA RealArg RealArgsList
                |
                (EpsilonRealArgsList) /* epsilon */;
RealArg ::= Expr;

Condition ::= (OneCondition) ConditionTerm
              |
              (MoreCondition) Condition OR ConditionTerm;

ConditionTerm ::= (OneConditionFact) ConditionFact
                  |
                  (MoreConditionFacts) ConditionTerm AND ConditionFact;

ConditionFact ::= (ConditionFactExpr) Expr
                  |
                  (ConditionFactRelOp) Expr RelOp Expr;

ElseStatement ::= (ElseStatments) ELSE Statement
                  |
                  (EpsilonElse) /* epsilon */;




